#############################################################################
# Copyright 2022 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.
#############################################################################

"""
Interactor:
    Allows interaction between the different pieces.
"""

from abc import ABC, abstractmethod
from repometer.core.response import ResponseFactory, DictionaryConverter
import repometer.core.request as requestapi
from repometer.core.repoapi import (VCSAPISessionFactory,
                                  RequestFailureException,
                                  StrategyExecutionException)
from repometer.database.database import DatabaseAPIFactory, DBAPIException


class InteractorException(RuntimeError):
    """An runtime exception generated by an Interactor."""


class InteractorFactory:
    """
    A factory for churning out interactor objects. Classes should use this
    factory to construct interactors.
    """
    @staticmethod
    def createOrchestrator():
        return Orchestrator()

    @staticmethod
    def createAddCustomerInteractor():
        return AddCustomerInteractor()

    @staticmethod
    def createRemoveCustomerInteractor():
        return RemoveCustomerInteractor()

    @staticmethod
    def createAddVCSAccountInteractor():
        return AddVCSAccountInteractor()

    @staticmethod
    def createRemoveVCSAccountInteractor():
        return RemoveVCSAccountInteractor()

    @staticmethod
    def createAddRepositoryInteractor():
        return AddRepositoryInteractor()

    @staticmethod
    def createRemoveRepositoryInteractor():
        return RemoveRepositoryInteractor()

    @staticmethod
    def createGetObservationsForRepositoryInteractor():
        return GetObservationsForRepositoryInteractor()

    @staticmethod
    def createCollectObservationsInteractor():
        return CollectObservationsInteractor()

    @staticmethod
    def createStatusInteractor():
        return StatusInteractor()


class TrafficInteractor(ABC):
    """
    The base class for the central component(s) of Repometer, responsible for
    bridging the divide between the VCS, database, and delivery components.
    """

    @abstractmethod
    def canHandleRequest(self, request):
        """
        Checks whether this interactor declares that it is able to perform
        a given request. Interactors are responsible for affirming which
        request types they are programmed to perform.

        Parameters
        ----------
        request:
            A RequestModel object.
        """
        pass

    @abstractmethod
    def execute(self, request):
        """
        Perform the request.

        Parameters
        ----------
        request:
            A RequestModel object.

        Returns
        -------
        response:
            A ResponseModel object.
        """


class Orchestrator(TrafficInteractor):
    """
    The orchestrator is a composite interactor:
    it can delegate tasks to child interactors.
    """

    def __init__(self):
        # A container for other interactors joined under the Orchestrator.
        self._children = []

    def addChild(self, interactor):
        """
        Parameters
        ----------
        interactor:
            A TrafficInteractor object.
        """
        self._children.append(interactor)

    def hasChild(self, interactor):
        return interactor in self._children

    def getNumberOfChildren(self):
        return len(self._children)

    def removeChild(self, interactor):
        self._children.remove(interactor)

    def canHandleRequest(self, request):
        for child in self._children:
            if child.canHandleRequest(request):
                return True
        return False

    def execute(self, request):
        for child in self._children:
            if child.canHandleRequest(request):
                return child.execute(request)
        return ResponseFactory.createFailureResponse(
            message="No interactor was found that could satisfy the \
                request ({requestType}).".format(requestType=type(request)))


class AddCustomerInteractor(TrafficInteractor):

    def canHandleRequest(self, request):
        if isinstance(request, requestapi.AddCustomerRequest):
            return True
        else:
            return False

    def execute(self, request):
        if request.hasErrors():
            return ResponseFactory.createFailureResponse(
                message="The request had errors in it and cannot be processed\
                    (see attachment).", attachments=request.getErrors())

        customerToAdd = request.getCustomer()

        with DatabaseAPIFactory.createDefaultDBAPI() as db:
            if db.customerExists(customerToAdd):
                return ResponseFactory.createFailureResponse(
                    message="A customer with that name already exists \
                        in the database. Aborting.")
            db.addCustomer(customerToAdd)

        return ResponseFactory.createSuccessResponse(
            message="Customer ({customerName}) added to database.".format(
                customerName=customerToAdd.getCustomerName()))


class RemoveCustomerInteractor(TrafficInteractor):

    def canHandleRequest(self, request):
        if isinstance(request, requestapi.RemoveCustomerRequest):
            return True
        else:
            return False

    def execute(self, request):
        if request.hasErrors():
            return ResponseFactory.createFailureResponse(
                message="The request had errors in it and cannot be processed\
                    (see attachment).", attachments=request.getErrors())

        customerToRemove = request.getCustomer()

        with DatabaseAPIFactory.createDefaultDBAPI() as db:
            if not db.customerExists(customerToRemove):
                return ResponseFactory.createFailureResponse(
                    message="A customer with that name does not already \
                        exist in the database. Aborting.")
            db.removeCustomer(customerToRemove)

        return ResponseFactory.createSuccessResponse(
            message="Customer ({customerName}) removed from database.".format(
                customerName=customerToRemove.getCustomerName()))


class StatusInteractor(TrafficInteractor):

    def canHandleRequest(self, request):
        if isinstance(request, requestapi.StatusRequest):
            return True
        else:
            return False

    def execute(self, request):
        try:
            db = DatabaseAPIFactory.createDefaultDBAPI()
            canConnectToDatabase = True
        except DBAPIException:
            canConnectToDatabase = False

        statusMessage = """
        ðŸŒ Repometer Status ðŸŒ
        Database Status: {databaseStatus}
        """.format(
        databaseStatus = "âœ… ONLINE" if canConnectToDatabase else "âŒ OFFLINE")

        return ResponseFactory.createSuccessResponse(
            message=statusMessage)



class AddVCSAccountInteractor(TrafficInteractor):

    def canHandleRequest(self, request):
        if isinstance(request, requestapi.AddVCSAccountRequest):
            return True
        else:
            return False

    def execute(self, request):
        if request.hasErrors():
            return ResponseFactory.createFailureResponse(
                message="The request had errors in it and cannot be processed\
                    (see attachment).", attachments=request.getErrors())

        vcsToAdd = request.getVCSAccount()
        tokenToAdd = request.getAccessToken()
        associatedCustomer = request.getCustomer()

        with DatabaseAPIFactory.createDefaultDBAPI() as db:
            if db.accountExists(vcsToAdd):
                return ResponseFactory.createFailureResponse(
                    message="An account with that name already exists in \
                        the database. Aborting.")
            db.addAccount(associatedCustomer, vcsToAdd, tokenToAdd)

        return ResponseFactory.createSuccessResponse(
            message="VCS Account ({vcsName}) added to database.".format(
                vcsName=vcsToAdd.getUsername()))


class RemoveVCSAccountInteractor(TrafficInteractor):

    def canHandleRequest(self, request):
        if isinstance(request, requestapi.RemoveVCSAccountRequest):
            return True
        else:
            return False

    def execute(self, request):
        if request.hasErrors():
            return ResponseFactory.createFailureResponse(
                message="The request had errors in it and cannot be processed\
                    (see attachment).", attachments=request.getErrors())

        accountToRemove = request.getVCSAccount()
        associatedCustomer = request.getCustomer()

        with DatabaseAPIFactory.createDefaultDBAPI() as db:
            if not db.accountExists(accountToRemove):
                return ResponseFactory.createFailureResponse(
                    message="An account with that name does not already exist in\
                        the database. Aborting.")
            db.removeAccount(associatedCustomer, accountToRemove)

        return ResponseFactory.createSuccessResponse(
            message="Account ({accountName}) removed from\
                database.".format(accountName=accountToRemove.getUsername()))


class AddRepositoryInteractor(TrafficInteractor):

    def canHandleRequest(self, request):
        if isinstance(request, requestapi.AddRepositoryRequest):
            return True
        else:
            return False

    def execute(self, request):
        if request.hasErrors():
            return ResponseFactory.createFailureResponse(
                message="The request had errors in it and cannot be processed\
                    (see attachment).", attachments=request.getErrors())

        associatedVCSAccount = request.getVCSAccount()
        repositoryToAdd = request.getRepository()

        with DatabaseAPIFactory.createDefaultDBAPI() as db:
            if not db.accountExists(associatedVCSAccount):
                return ResponseFactory.createFailureResponse(
                    message="The VCS account associated with this \
                        repository does not exist in the database. Aborting.")
            if db.repoExists(associatedVCSAccount, repositoryToAdd):
                return ResponseFactory.createFailureResponse(
                    message="A repository associated with the VCS account \
                        already exists in the database. Aborting.")
            db.addRepository(associatedVCSAccount, repositoryToAdd)

        return ResponseFactory.createSuccessResponse(message="Added repository\
                                                     {repoName}, associated \
                                                     with {accountName}".format(
            repoName=repositoryToAdd.getCanonicalName(),
            accountName=associatedVCSAccount.getUsername()))


class RemoveRepositoryInteractor(TrafficInteractor):

    def canHandleRequest(self, request):
        if isinstance(request, requestapi.RemoveRepositoryRequest):
            return True
        else:
            return False

    def execute(self, request):
        if request.hasErrors():
            return ResponseFactory.createFailureResponse(
                message="The request had errors in it and cannot be processed\
                    (see attachment).", attachments=request.getErrors())

        associatedVCSAccount = request.getVCSAccount()
        repositoryToRemove = request.getRepository()

        with DatabaseAPIFactory.createDefaultDBAPI() as db:
            if not db.accountExists(associatedVCSAccount):
                return ResponseFactory.createFailureResponse(
                    message="The VCS account associated with this \
                        repository does not exist. Aborting.")
            if not db.repoExists(associatedVCSAccount, repositoryToRemove):
                return ResponseFactory.createFailureResponse(
                    message="The repository does not exist in the database.\
                        Aborting.")
            if not db.accountRepositoryAssociated(
                    associatedVCSAccount, repositoryToRemove):
                return ResponseFactory.createFailureResponse(
                    message="The repository exists in the database, but the\
                        VCS account is not tracking that database.")

            db.removeRepository(associatedVCSAccount, repositoryToRemove)

        return ResponseFactory.createSuccessResponse(message="Removed \
                                                     repository {repoName}, \
                                                     associated with \
                                                     {accountName}".format(
            repoName=repositoryToRemove.getCanonicalName(),
            accountName=associatedVCSAccount.getUsername()))


class GetObservationsForRepositoryInteractor(TrafficInteractor):
    def canHandleRequest(self, request):
        if isinstance(request, requestapi.GetObservationsForRepositoryRequest):
            return True
        else:
            return False

    def execute(self, request):
        if request.hasErrors():
            return ResponseFactory.createFailureResponse(
                message="The request had errors in it and cannot be processed\
                    (see attachment).", attachments=request.getErrors())

        associatedVCSAccount = request.getVCSAccount()
        repository = request.getRepository()
        associatedCustomer = request.getCustomer()

        with DatabaseAPIFactory.createDefaultDBAPI() as db:
            if not db.accountExists(associatedVCSAccount):
                return ResponseFactory.createFailureResponse(
                    message="The VCS account associated with this \
                        repository does not exist. Aborting.")
            if not db.repoExists(associatedVCSAccount, repository):
                return ResponseFactory.createFailureResponse(
                    message="The repository does not exist in the database.\
                        Aborting.")

            if not db.accountRepositoryAssociated(associatedVCSAccount,
                                                 repository):
                return ResponseFactory.createFailureResponse(
                    message="The repository exists in the database, but the\
                        VCS account is not tracking that database.")

            observations = db.getObservations(associatedVCSAccount, repository)
            converter = DictionaryConverter()
            observations = [converter.convert(
                observation) for observation in observations]

            return ResponseFactory.createSuccessResponse(message="Fetched all\
                                                         data for {repoName} \
                                                         (see \
                                                         attachment)".format(
                repoName=repository.getCanonicalName()),
                attachments=observations)


class CollectObservationsInteractor(TrafficInteractor):
    def canHandleRequest(self, request):
        if isinstance(request, requestapi.CollectObservationsRequest):
            return True
        else:
            return False

    def execute(self, request):
        if request.hasErrors():
            return ResponseFactory.createFailureResponse(
                message="The request had errors in it and cannot be processed\
                    (see attachment).", attachments=request.getErrors())

        try:
            db = DatabaseAPIFactory.createDefaultDBAPI()
        except DBAPIException as dbException:
            return ResponseFactory.createFailureResponse(message="\
                    CollectObservationsInteractor encountered an exception\
                    when trying to access the database (see\
                    attachment).", attachments=[dbException])

        customers = db.getAllCustomers()
        failures = {}
        for customer in customers:
                accounts = db.getCustomerAccounts(customer)
                for account in accounts:
                        repositories = db.getAccountRepositories(account)
                        token = db.getToken(customer, account)
                        for repository in repositories:
                            try:
                                session = VCSAPISessionFactory.createAppropriateAPISessionWithStrategies(token,repository)
                                session.executeStrategies()
                                observations = session.collectResults()
                                db.insertObservations(account, repository, observations)
                            except (RequestFailureException,
                                    StrategyExecutionException,
                                    DBAPIException) as exception:
                                customerName = customer.getCustomerName()
                                accountUsername = account.getUsername()
                                repositoryName = repository.getCanonicalName()
                                failures["{customer}:{account}:{repo}".format(customer=customerName,account=accountUsername,
                                         repo=repositoryName)] = exception
                                continue
                            except Exception as unexpectedException:
                                return ResponseFactory.createFailureResponse(message="CollectObservationsInteractor\
                            encountered an unexpected exception ({exceptionType})\
                            and terminated immediately as a precaution.".format(
                                    exceptionType=type(unexpectedException)),
                                    attachments=[unexpectedException])

        if len(failures) == 0:
            return ResponseFactory.createSuccessResponse(
                message="Completed data collection pass.")
        else:
            summary = ""
            for customerAndRepo in failures:
                exception = failures[customerAndRepo]
                if exception.__cause__ is not None:
                    summary += "    âŒ {customerAndRepo} -> {exceptionType}\
                        (underlying cause: {causeType})\n".format(
                        customerAndRepo=customerAndRepo,
                        exceptionType=type(exception),
                        causeType=type(exception.__cause__))
                else:
                    summary += "    âŒ {customerAndRepo} -> {exceptionType}\
                        \n".format(
                        customerAndRepo=customerAndRepo,
                        exceptionType=type(exception))
            return ResponseFactory.createFailureResponse(
                message="Data collection pass completed, \
                    but Repometer encountered one or more exceptions \
                    when collecting customer data \n{summary}".format(
                        summary=summary),
                attachments=[failures])
